## This page needs work!

Please read [this](http://netty.io/4.0/guide/) until the user guide is fully moved to the wiki.

## Preface
### The Problem
Nowadays we use general purpose applications or libraries to communicate with each other. For example, we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services.

However, a general purpose protocol or its implementation sometimes does not scale very well. It is like we don't use a general purpose HTTP server to exchange huge files, e-mail messages, and near-realtime messages such as financial information and multiplayer game data. What's required is a highly optimized protocol implementation which is dedicated to a special purpose. For example, you might want to implement an HTTP server which is optimized for AJAX-based chat application, media streaming, or large file transfer. You could even want to design and implement a whole new protocol which is precisely tailored to your need.

Another inevitable case is when you have to deal with a legacy proprietary protocol to ensure the interoperability with an old system. What matters in this case is how quickly we can implement that protocol while not sacrificing the stability and performance of the resulting application.

## The Solution
[The Netty project] is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance Â· high-scalability protocol servers and clients.

In other words, Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server development.

'Quick and easy' does not mean that a resulting application will suffer from a maintainability or a performance issue. Netty has been designed carefully with the experiences earned from the implementation of a lot of protocols such as FTP, SMTP, HTTP, and various binary and text-based legacy protocols. As a result, Netty has succeeded to find a way to achieve ease of development, performance, stability, and flexibility without a compromise.

Some users might already have found other network application framework that claims to have the same advantage, and you might want to ask what makes Netty so different from them. The answer is the philosophy where it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from the day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty.

## Getting Started
This chapter tours around the core constructs of Netty with simple examples to let you get started quickly. You will be able to write a client and a server on top of Netty right away when you are at the end of this chapter.

If you prefer top-down approach in learning something, you might want to start from Chapter 2, Architectural Overview and get back here.

### Before Getting Started
The minimum requirements to run the examples which are introduced in this chapter are only two; the latest version of Netty and JDK 1.7 or above. The latest version of Netty is available in [the project download page](http://netty.io/downloads). To download the right version of JDK, please refer to your preferred JDK vendor's web site.

As you read, you might have more questions about the classes introduced in this chapter. Please refer to the API reference whenever you want to know more about them. All class names in this document are linked to the online API reference for your convenience. Also, please don't hesitate to [contact the Netty project community](http://netty.io/community.html) and let us know if there's any incorrect information, errors in grammar and typo, and if you have a good idea to improve the documentation.

### Writing a Discard Server
The most simplistic protocol in the world is not 'Hello, World!' but [`DISCARD`](http://tools.ietf.org/html/rfc863). It's a protocol which discards any received data without any response.

To implement the `DISCARD` protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.

    package io.netty.example.discard;
    
    import io.netty.channel.ChannelHandlerContext;
    import io.netty.channel.ChannelInboundHandlerAdapter;
    import io.netty.channel.MessageList;
    
    import java.util.logging.Level;
    import java.util.logging.Logger;
    
    /**
     * Handles a server-side channel.
     */
    public class DiscardServerHandler extends ChannelInboundHandlerAdapter {
    
        private static final Logger logger = Logger.getLogger(
                DiscardServerHandler.class.getName());
    
        @Override
        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
            // Discard the received data silently.
            msgs.releaseAllAndRecycle();
        }
    
        @Override
        public void exceptionCaught(ChannelHandlerContext ctx,
                Throwable cause) throws Exception {
            // Close the connection when an exception is raised.
            logger.log(
                    Level.WARNING,
                    "Unexpected exception from downstream.",
                    cause);
            ctx.close();
        }
    }

* `DiscardServerHandler` extends [`ChannelInboundHandlerAdapter`], which is an implementation of [`ChannelInboundHandler`]. `ChannelInboundHandler` provides various event handler methods that you can override. For now, it is just enough to extend `ChannelInboundHandlerAdapter` rather than to implement the handler interface by yourself.
* We override the `messageReceived()` event handler method here. This method is called with a [`MessageList `], which contains the received data, whenever new data is received from a client. In this example, we just discard the received data by calling `releaseAllAndRecycle()` on the `MessageList ` to implement the `DISCARD` protocol.
* The `exceptionCaught()` event handler method is called with a Throwable when an exception was raised by Netty due to I/O error or by a handler implementation due to the exception thrown while processing events. In most cases, the caught exception should be logged and its associated channel should be closed here, although the implementation of this method can be different depending on what you want to do to deal with an exceptional situation. For example, you might want to send a response message with an error code before closing the connection.

So far so good. We have implemented the first half of the `DISCARD` server. What's left now is to write the `main()` method which starts the server with the `DiscardServerHandler`.

	package io.netty.example.discard;
	
	import java.net.InetSocketAddress;
	
	import io.netty.bootstrap.ServerBootstrap;
	import io.netty.channel.ChannelFuture;
	import io.netty.channel.ChannelInitializer;
	import io.netty.channel.ChannelOption;
	import io.netty.channel.nio.NioEventLoopGroup;
	import io.netty.channel.socket.SocketChannel;
	import io.netty.channel.socket.nio.NioServerSocketChannel;
	
	public class DiscardServer {
		public static void main(String[] args) throws Exception {
			ServerBootstrap bootstrap = new ServerBootstrap();
			try {
				bootstrap.group(new NioEventLoopGroup(), new NioEventLoopGroup())
					.channel(NioServerSocketChannel.class)
					.childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel channel) {
							channel.pipeline().addLast(new DiscardServerHandler());
						}
					})
					.childOption(ChannelOption.TCP_NODELAY, true)
					.childOption(ChannelOption.SO_KEEPALIVE, true);
				
				ChannelFuture future = bootstrap.bind(new InetSocketAddress(8080)).sync();
				
				future.channel().closeFuture().sync();
			} finally {
				bootstrap.shutdown();
			}
		}
	}

* [`ServerBootstrap`] is a helper class that sets up a server. You can set up the server using a [`Channel`] directly. However, please note that this is a tedious process and you do not need to do that in most cases.
* [`NioEventLoopGroup`] processes all I/O requests and performs I/O. Netty provides various [`EventLoopGroup`] implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two `NioEventLoopGroup` will be used. The first is used to handle the accept of new connections and the second will serve the I/O of them. The used `EventLoopGroup` implementation is resposible to manage its used threads. How many Threads are used and how they are mapped to the created `Channel`s depends on the implementation and may be even configurable via the constructor. Please refer to the apidocs.
* Here, we specify to use the `NioServerSocketChannel` class which will be used to instance a new `Channel` that will accept new connections.
* Here, we configure the [`ChannelInitializer`]. Whenever a new connection is accepted by the server, it will be called. Most of the times you want to add [`ChannelHandler`]s to the pipeline of the accepted connection. In this example we add the `DiscardServerHandler`. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top level class eventually.
* You can also set the parameters which are specific to the `Channel` implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as `tcpNoDelay` and `keepAlive`. Please refer to the apidocs of [`ChannelOption`] and the specific [`ChannelConfig`] implementations to get an overview about the supported `ChannelOption`s.
* We are ready to go now. What's left is to bind to the port and to start the server. Here, we bind to the port `8080` of all NICs (network interface cards) in the machine. You can now call the `bind()` method as many times as you want (with different bind addresses.)

Congratulations! You've just finished your first server on top of Netty.


[The Netty project]: http://netty.io/

[`Channel`]: http://netty.io/4.0/api/io/netty/channel/Channel.html
[`ChannelConfig`]: http://netty.io/4.0/api/io/netty/channel/ChannelConfig.html
[`ChannelHandler`]: http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html
[`ChannelInboundHandler`]: http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html
[`ChannelInboundHandlerAdapter`]: http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html
[`ChannelInitializer`]: http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html
[`ChannelOption`]: http://netty.io/4.0/api/io/netty/channel/ChannelOption.html
[`EventLoopGroup`]: http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html
[`MessageList`]: http://netty.io/4.0/api/io/netty/channel/MessageList.html
[`NioEventLoopGroup`]: http://netty.io/4.0/api/io/netty/channel/nio/NioEventLoopGroup.html
[`ServerBootstrap`]: http://netty.io/4.0/api/io/netty/bootstrap/ServerBootstrap.html